{% extends 'expense_base.html' %}

{% block content %}
	<h3>Hard Wood Laminate</h3>
	    <label for="interval">Interval:</label>
	    <select id="interval" onchange="get_data(this)">
	    	<option value="WEEK">Week</option>
	    	<option value="MONTH">Month</option>
	    	<option value="THREEMONTHS">3 Months</option>
	    </select>
	<div id="button-div">
	    <button id="make_chart_btn" onclick="make_expense_chart(this)" class="btn btn-success">expense chart</button>
	    <button id="make_fund_chart_btn" onclick="make_fund_chart(this)" class="btn btn-info">fund chart</button>
	    <button id="make_category_chart_btn" onclick="make_category_chart(this)" class="btn btn-secondary">category chart</button>
	</div>
	<div id="canvas_div_id">
	</div>
	<div id="control-div">
	</div>
	<div id="table-div">
	</div>	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.5.1/chart.min.js" integrity="sha512-Wt1bJGtlnMtGP0dqNFH1xlkLBNpEodaiQ8ZN5JLA5wpc1sUlk/O5uuOMNgvzddzkpvZ9GLyYNa8w2s7rqiTk5Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

	<script type="text/javascript">
		// the expense data from the selected interval
		let raw_expense_data = [];
		let fund_names = {};
		let category_names = {};

		// get the data from the server
		const get_data = async () => {
			const res = await fetch('{{domain}}?interval='+interval.value);
			const data = await res.json();
			// set the variable
			raw_expense_data = data["expense_data"];
			fund_names = data["fund_names"];
			category_names = data["category_names"];
			// generate the controls
			createControls()
			console.log(data["fund_names"])
			console.log(data["category_names"])
			return data
		}

		const createControls = () => {
			// remove all the elements on the control div
			controlDiv.innerHTML = '';
			createSelectControl(fund_names, 'fund', 'fund-control', createTable);
			createSelectControl(category_names, 'category', 'category-control', createTable);
		}

		// filter expenses bases on selected controls
		const filterData = () => {
			// data processing section
			let fund_select = document.getElementById('fund-control');
			let category_select = document.getElementById('category-control');
			let expenses = raw_expense_data;
			// if the fund selected is not all
			// fiter the data to the selected fund
			if(fund_select.value != -1) expenses = expenses.filter((expense) => expense['fund'] == fund_select.value);
			// if category is not all
			// filter the data based on the value of category
			if(category_select.value != -1) expenses = expenses.filter((expense) => expense['category'] == category_select.value);
			return expenses;
		}

		// create a table base on fund and category
		const createTable = () => {
			let expenses = filterData();
			// table to tabulate all of the expense data
			let table = document.createElement("TABLE");
			table.className = "table";
			// loop thriugh all the expense data
			// and create a row for each expense entry
			expenses.forEach((expense, i) => {
				// insert a row on table for each expense entry
				let row = table.insertRow(i);
				// the properties of the expense such as desctription, price, ...etc
				let expense_properties = Object.keys(expense);
				expense_properties.forEach((expense_property, j) => {
					// the value of the expense property i.e. description="pambili ng ulam"
					let expense_property_value = expense[expense_property];
					// add the cells that contain the properties of the expenses
					let cell = row.insertCell(j);
					if(expense_property == 'fund'){
						cell.innerHTML = fund_names[expense_property_value];
					}else if(expense_property == 'category'){
						cell.innerHTML = category_names[expense_property_value];
					}else{
						cell.innerHTML = expense_property_value
					}
				});
			});
			// empty the div first before adding the new table
			tableDiv.innerHTML = '';
			tableDiv.appendChild(table);
		}

		// create options for a select
		const createSelectControl = (key_value_dict, label_name, id, func) => {
			let select_object = document.createElement("SELECT");
			select_object.id = id;
			select_object.onchange = func
			let label = document.createElement("LABEL");
			label.htmlFor = select_object.id;
			label.innerHTML = label_name;

			// add an option to select all
			let all_option = document.createElement("OPTION");
			all_option.text = "ALL";
			all_option.value = -1;
			// add the option to the select object
			select_object.add(all_option);
			// generate options
			let keys = Object.keys(key_value_dict);
			keys.forEach((key) => {
				let new_option = document.createElement("OPTION");
				new_option.text = key_value_dict[key];
				new_option.value = key;
				// add the option to the select object
				select_object.add(new_option);
			});

			// add the select object and label to control div
			controlDiv.appendChild(label);
			controlDiv.appendChild(select_object);
		}

		// make a expense chart
		const make_expense_chart = async() =>{
			var chart_data = process_chart_data(raw_expense_data.map((data) => data.price), raw_expense_data.map((data) => data.timestamp.slice(5, 10)));
			make_chart(chart_data, "expenses");
		}

		// make a chart for fund and category
		const make_fund_chart = () => {
			let fund = raw_expense_data.map((expense) => expense.fund);
			let price = raw_expense_data.map((expense) => expense.price)
			let chart_data = findAllIndices(fund, price);
			chart_data["labels"] = chart_data["labels"].map((label) => fund_names[label]);
			make_chart(chart_data, "Total Expenses per Fund");
		}

		// make a chart for fund and category
		const make_category_chart = () => {
			let category = raw_expense_data.map((expense) => expense.category);
			let price = raw_expense_data.map((expense) => expense.price)
			let chart_data = findAllIndices(category, price);
			chart_data["labels"] = chart_data["labels"].map((label) => category_names[label]);
			make_chart(chart_data, "Total Expenses per Category");
		}

		// make a chart
		const make_chart = (chart_data, label) => {
			// create a new canvas inside the canvas div
			canvasDiv.innerHTML = '';
			const ctx = document.createElement('canvas');
			ctx.id = 'myChart';
			
			// create the dataset that will be used by the chart
			dataset = {
				label: label,
				data: chart_data.data,
				backgroundColor: getRandomColors(chart_data.data.length),
				borderWidth: 1
			}

			// the actual chart object
			var myChart = new Chart(ctx,{
				type: 'pie',
				data: {
					labels: chart_data.labels,
					datasets: [dataset]
				},
				options:{
					scales:{
						y:{
							beginAtZero:true
						}
					}
				}
			});

			canvasDiv.appendChild(ctx);

		}
		// helper functions 

		// count the consecutive occurence of an element in given index on a given array
		// ex. arr = [1,2,3,3,3,4,4,5,5,9,9,9]
		// count_consec_occur(arr, 2, 3) = 3
		// counts the number of times 3 appears on the array on the index 2
		const count_consec_occur = (array, start_index, element) => {
			var occurence_count = 0;
			for(let i = start_index; i < array.length; i++){
				var cur_val = array[i];
				if(cur_val == element){ occurence_count++ }
				else{ break; }
			}
			return occurence_count;
		}
		// compute the sum of all the elements of the array
		// from start index to the end index(exclusive)
		const sum_fr_to = (array, start_index, end_index) => {
			sum = 0;
			for(let i = start_index; i < end_index; i++){
				sum += array[i];
			}
			return sum
		}

		// generate a random rgba color
		const randomColor = () => {
			var o = Math.round, r = Math.random, s = 255;
			return 'rgba(' + o(r()*s) + ',' + o(r()*s) + ',' + o(r()*s) + ',' + r().toFixed(1) + ')';
		}
		// get an array of random rgba colors
		const getRandomColors = size => {
			var colors = []
			for(var i = 0; i < size; i++){
				colors.push(randomColor());
			}
			return colors;
		}
		// process the data from the server 
		// to return a dictionary than can be used for makeChart
		const process_chart_data = (array_1, array_2) => {
			var chart_data = {data:[], labels:[]}
			var i = 0;
			while(i < array_2.length){
				let cur_val = array_2[i];
				let count = count_consec_occur(array_2, i, cur_val);
				let sum = sum_fr_to(array_1, i, i+count);
				chart_data["data"].push(sum);
				chart_data["labels"].push(cur_val)
				i += count;
			} 
			return chart_data;
		}
		// some fancy function, i cant explian it for now

		// find all the indices of the target element
		const findIndices = (items, target) => {
			let indices = [];
			items.forEach((item, index) => {
				if(target == item){
					indices.push(index);
				}
			})
			return indices;
		}

		// get the sum of the elements of a given array of indices
		const sumElementOfIndices = (array, indices_array) => {
			let sum = 0;
			indices_array.forEach((index) => {
				sum += array[index]
			})
			return sum;
		}

		// find all of the indices of the unique elements of the array
		const findAllIndices = (items, array) => {
			let unique = items.filter((e, i, a) => a.indexOf(e) == i);
			let object = {labels:unique, data:[]};
			unique.forEach((item) => {
				object["data"].push(sumElementOfIndices(array, findIndices(items, item)));
			})
			console.log(object);
			return object;
		}

		let interval = document.getElementById('interval');
		let canvasDiv = document.getElementById('canvas_div_id');
		let controlDiv = document.getElementById('control-div');
		let tableDiv = document.getElementById('table-div');
	</script>
{% endblock %}